<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>バレースコア記録</title>
<style>
  html,
  body {
    height: 100%;
    margin: 0;
    padding: 0;
  }

  body {
    font-family: system-ui, -apple-system, "Hiragino Kaku Gothic ProN", "メイリオ", Meiryo, sans-serif;
    background: linear-gradient(180deg, #f6f7fb, #ffffff);
    -webkit-text-size-adjust: 100%;
  }

  main {
    max-width: 980px;
    margin: 20px auto;
    background: rgba(255, 255, 255, 0.95);
    padding: 16px;
    border-radius: 8px;
    box-shadow: 0 6px 18px rgba(0, 0, 0, 0.06);
  }

  h1 {
    font-size: 20px;
    margin: 0 0 12px;
  }

  h2 {
    font-size: 18px;
    margin: 16px 0 8px;
  }

  h3 {
    font-size: 16px;
    margin-bottom: 8px;
    border-bottom: 1px dashed #eee;
    padding-bottom: 4px;
  }

  .row {
    display: flex;
    gap: 8px;
    align-items: center;
    margin-bottom: 8px;
    flex-wrap: wrap;
  }

  #players {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 10px;
    margin: 10px 0;
  }

  @media(max-width:700px) {
    #players {
      grid-template-columns: repeat(3, 1fr);
    }
  }

  @media(max-width:500px) {
    #players {
      grid-template-columns: repeat(2, 1fr);
    }
  }

  .player {
    background: #fbfdff;
    border: 1px solid #e6eefb;
    padding: 10px;
    border-radius: 8px;
    display: flex;
    flex-direction: column;
    gap: 8px;
    align-items: stretch;
    position: relative;
  }

  .player h3 {
    margin: 0;
    font-size: 16px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    border-bottom: none;
    padding-bottom: 0;
  }

  .sub-btn {
    flex-grow: 1;
    padding: 8px 6px;
    font-size: 14px;
    background: #e5f7e7;
    border-color: #a8e0ae;
    color: #185a1f;
  }

  button {
    padding: 6px 10px;
    border-radius: 6px;
    border: 1px solid #ccc;
    background: #fff;
    cursor: pointer;
    transition: background 0.1s;
  }

  button:active {
    opacity: 0.8;
  }

  button.action {
    background: #eef9ff;
    border-color: #bde0ff;
    font-weight: 500;
  }

  #actions {
    margin-top: 20px;
  }

  .action-buttons {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
  }

  #otherLostPoint {
    background: #fdeeee;
    border-color: #f8c5c5;
    color: #9b2c2c;
  }

  #otherPoint {
    background: #fff9e6;
    border-color: #ffecb3;
    color: #6d5813;
  }

  #logSection {
    margin-top: 20px;
  }

  .log-tabs {
    display: flex;
    border-bottom: 2px solid #eee;
    margin-bottom: 8px;
  }

  .log-tab-btn {
    padding: 8px 15px;
    cursor: pointer;
    border: none;
    background: transparent;
    font-size: 16px;
    margin-right: 5px;
    border-bottom: 2px solid transparent;
  }

  .log-tab-btn.active {
    border-bottom: 2px solid #2a66b9;
    font-weight: bold;
    color: #2a66b9;
    background: #f6f7fb;
  }

  
  /* ★★★ CSS 修正箇所 ★★★ */
  /* (flex-direction: column-reverse; を削除し、 column; (通常の上から下) に変更) */
  #log {
    max-height: 300px;
    overflow-y: auto;
    padding-left: 0;
    background: #f9fafb;
    border-radius: 6px;
    padding: 8px;
    list-style-type: none;
    display: flex;
    flex-direction: column; /* ★修正 */
  }

  #log li {
    padding: 6px 8px;
    border-bottom: 1px dashed #eee;
    font-size: 14px;
  }

  #log li:first-child {
    border-bottom: none;
  }

  .modal {
    position: fixed;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(0, 0, 0, 0.6);
    z-index: 1000;
  }

  .modal.hidden {
    display: none;
  }

  .modal-content {
    background: #fff;
    padding: 16px;
    border-radius: 12px;
    min-width: 320px;
    max-width: 90%;
    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
    max-height: 90vh;
    overflow-y: auto;
  }

  .modal-actions {
    display: flex;
    gap: 8px;
    justify-content: flex-end;
    margin-top: 16px;
  }

  input[type="text"],
  input[type="number"],
  select,
  textarea {
    padding: 8px;
    border-radius: 6px;
    border: 1px solid #ddd;
    font-size: 15px;
    width: 100%;
    box-sizing: border-box;
  }

  label {
    font-size: 14px;
  }

  .top-right {
    position: absolute;
    right: 14px;
    top: 14px;
    font-size: 12px;
    opacity: 0.8;
  }

  .modal-form-row {
    margin-bottom: 12px;
  }

  .modal-form-row label {
    display: block;
    margin-bottom: 4px;
    font-weight: 500;
  }

  .modal-form-row h4 {
    margin: 0 0 4px;
    font-size: 16px;
  }

  .choice-list {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin-top: 8px;
    max-height: 150px;
    overflow-y: auto;
    padding: 4px;
    border: 1px solid #eee;
    border-radius: 6px;
  }

  .choice-label input[type="radio"] {
    display: none;
  }

  .choice-label {
    padding: 8px 12px;
    border: 1px solid #ddd;
    border-radius: 6px;
    cursor: pointer;
    transition: background 0.2s, border-color 0.2s;
    font-size: 14px;
    font-weight: 500;
    line-height: 1;
  }

  .choice-label:hover {
    background: #f0f0f0;
  }

  .choice-label input[type="radio"]:checked+span {
    background: #2196F3;
    color: white;
    border-color: #2196F3;
  }

  .choice-label input[type="radio"]:checked+span:hover {
    background: #1e88e5;
  }

  #allPlayersContainer h3 {
    font-size: 16px;
    margin-bottom: 8px;
    border-bottom: 1px dashed #eee;
    padding-bottom: 4px;
  }

  .player-register-row {
    display: flex;
    gap: 8px;
    margin-bottom: 8px;
    align-items: center;
  }

  .player-register-row button {
    flex-shrink: 0;
    padding: 8px 10px;
  }

  .player-register-name-input {
    flex-grow: 1;
  }

  /* --- エクスポート画面 --- */
  #exportModal .modal-content {
    max-width: 95%;
    min-width: 90%;
    margin: 20px;
    max-height: 90vh;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
  }

  #exportInfo {
    background: #eef9ff;
    border: 1px solid #bde0ff;
    padding: 8px 12px;
    border-radius: 8px;
    font-size: 14px;
    line-height: 1.4;
    font-weight: 500;
    margin-bottom: 15px;
    flex-shrink: 0;
    text-align: center;
  }

  #exportInfo p {
    margin: 0;
  }

  #exportScreen {
    background: #f8f8f8;
    padding: 10px;
    border-radius: 8px;
    margin-top: 0;
    overflow-x: auto;
    flex-shrink: 0;
  }

  #exportTable {
    border-collapse: collapse;
    font-size: 9px;
    background: white;
    width: 100%;
    border: 1px solid #ddd;
  }

  #exportTable th,
  #exportTable td {
    border: 1px solid #ddd;
    padding: 4px 3px;
    text-align: center;
    white-space: normal;
    min-width: 20px;/*30pxから変更*/
  }

  #exportTable th {
    background-color: #f2f2f2;
    font-weight: bold;
    color: #333;
    position: sticky;
    top: 0;
    z-index: 3;
  }
  #exportTable th:first-child{
    border-right:  1.3px solid #bbb;
  }
  

  /* ★修正(3): 選手名列 (背景色をth/td共に統一) */
  #exportTable td:first-child {
    text-align: center;
    min-width: 40px; /*50pxから変更*/
    position: sticky;
    left: 0;
    background-color: #f2f2f2; /* ★要望: th/td共に背景色を統一 */
    z-index: 2;
    border-right: 1.3px solid #bbb; /* 選手列の右線 */
    font-weight: 500;
  }

  /* ★修正: アクションカテゴリ区切り */
  #exportTable thead tr:first-child th[colspan] {
    border-right: 1.3px solid #bbb; /* アクションヘッダ(1行目)の右線 */
  }

  /* ★修正(1): ボディとヘッダー(2行目)の区切り線 */
  #exportTable th.category-divider,
  #exportTable tbody td.category-divider {
    border-right: 1.3px solid #bbb; /* 「その他」列の右線 */
  }
  
  /* (「機会」列の特別な背景色指定は削除済み) */


  /* ★修正: 得点グラフ */
  #scoreGraphContainer {
    margin-top: 15px;
    overflow-x: auto;
    padding-bottom: 5px;
    background: #fafafa;
    border-radius: 8px;
    border: 1px solid #eee;
    flex-shrink: 0;
  }

  #scoreGraphContainer h3 {
    margin: 8px 8px 5px;
    font-size: 14px;
  }

  .graph-viewport {
    display: flex;
    flex-wrap: nowrap;
    padding: 5px;
  }

  .graph-row {
    display: flex;
    flex-wrap: wrap;
    margin-bottom: 5px;
  }

  .graph-column {
    display: flex;
    flex-direction: column;
    align-items: center;
    position: relative;
    width: 35px;
    height: 100px;
    box-sizing: border-box;
    padding: 0 1px;
  }

  .graph-log {
    font-size: 8px;
    color: #555;
    text-align: center;
    height: 40px;
    overflow: hidden;
    word-break: break-all;
    margin-bottom: 1px;
    line-height: 1.2;
  }

  .graph-log.log-top {
    margin-bottom: 0px;
    margin-top: auto;
  }

  .graph-log.log-bottom {
    margin-top: 0px;
    margin-bottom: auto;
  }

  .graph-point-area {
    height: 24px;
    width: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
  }

  .graph-point {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 22px;
    height: 22px;
    border-radius: 50%;
    font-size: 9px;
    font-weight: bold;
    border: 1px solid;
    z-index: 1;
  }

  .graph-point.team {
    background-color: #e3f2fd;
    border-color: #90caf9;
    color: #1565c0;
  }

  .graph-point.opponent {
    background-color: #ffebee;
    border-color: #ef9a9a;
    color: #c62828;
  }

  #reflectionContainer {
    margin-top: 15px;
    flex-grow: 1;
    display: flex;
    flex-direction: column;
  }

  #reflectionContainer h3 {
    flex-shrink: 0;
  }

  #matchReflection {
    resize: none;
    height: auto;
    min-height: 80px;
    font-size: 14px;
    line-height: 1.5;
    flex-grow: 1;
  }

  #export-set-tabs .log-tab-btn {
    /* メイン画面の log-tab-btn スタイルを継承しつつ、集計画面での見栄えを調整 */
    padding: 6px 10px; /* パディングを少し小さく */
    font-size: 14px; /* フォントサイズを小さく */
    border: 1px solid #ddd;
    border-bottom: 1px solid #ccc; /* 下線とボタンの境界をきれいに見せる */
    border-radius: 4px 4px 0 0;
    margin-right: 2px;
    background: #fff;
    flex-shrink: 0; /* タブが縮まないようにする */
}

#export-set-tabs .log-tab-btn.active {
    /* アクティブなタブのスタイル */
    border-color: #2a66b9; /* 青い枠線 */
    border-bottom: 1px solid #fff; /* 下線が消えたように見せる */
    background: #f6f7fb;
    font-weight: bold;
    color: #2a66b9;
}

.modal-actions button {
  width: 50%; 
  padding: 2px 3px; 
  font-size: 14px; 
  font-weight: bold;
  border-radius: 5px;
  cursor: pointer; 
}
</style>
</head>
<body>
  <div class="top-right">Safari推奨</div>
  <main>
    <section id="controls">
      <h1>バレースコア記録</h1>
      <div class="row">
        <label>対戦相手: <input id="opponentName" value="相手チーム" inputmode="text"></label>
        <label>セット数: <input id="currentSet" type="number" min="0" value="1" style="width:50px; text-align:center;"></label>
        <label>リベロ有無:
          <select id="liberoStatus" style="width:auto;">
            <option value="7">リベロあり (7人)</option>
            <option value="6">リベロなし (6人)</option>
          </select>
        </label>
         <input type="file" id="jsonFileInput" accept=".json" style="display:none;">
<button id="importJsonButton">インポート(JSON)</button>
        <button id="newGame">新しい試合</button>
        <button id="showExportScreen">集計</button>
      </div>
    </section>
    <hr style="border:0;border-top:1px solid #eee;margin:20px 0;">

    <section id="set-controls" style="margin-bottom: 20px;">
        <h2>セット管理</h2>
        <div class="row" style="align-items: flex-end; display: flex;">
            <div id="set-tabs" class="log-tabs"    style="flex-grow: 1;">
            </div>
            <button id="nextSetButton" class="btn-primary">次のセットへ</button>
            <div id="nextSetConfirmModal" class="modal hidden">
              <div class="modal-content">
                <p id="nextSetConfirmMessage" style="text-align: center"></p>
                   <div class="modal-actions">
                     <button id="nextSetCancel" class="btn-secondary">キャンセル</button>
                      <button id="nextSetConfirm" class="btn-primary" style="background-color: #ffd0d2;">次のセットへ</button>
                 </div>
                </div>
              </div>
          </div>
    </section>

    <hr style="border:0;border-top:1px solid #eee;margin:20px 0;">
    <section id="allPlayersContainer">
      <h2>全選手登録・管理</h2>
      <div id="allPlayersList"></div>
      <div class="player-register-row">
        <input type="text" id="newPlayerName" placeholder="新しい選手名を入力" class="player-register-name-input" inputmode="text" autocomplete="off" />
        <button id="addPlayer">選手を追加</button>
      </div>
    </section>
    
    <hr style="border:0;border-top:1px solid #eee;margin:20px 0;">
    
    <h2>コート上のプレイヤー</h2>
    <section id="players"></section>
    
    <hr style="border:0;border-top:1px solid #eee;margin:20px 0;">
    
    <section id="actions">
      <h2>アクション記録</h2>
      <div class="action-buttons">
        <button class="action" data-action="サーブ" data-type="POINT_ACTION">サーブ</button>
        <button class="action" data-action="スパイク" data-type="POINT_ACTION">スパイク</button>
        <button class="action" data-action="ブロック" data-type="BLOCK">ブロック</button>
        <button class="action" data-action="レセ" data-type="SERVICE_RECEIVE">レセ</button>
        <button class="action" data-action="チャンス" data-type="DIG_RECEIVE">チャンス</button>
        <button class="action" data-action="ディグ" data-type="DIG_RECEIVE">ディグ</button>
        <button class="action" data-action="二段トス" data-type="SET">二段トス</button>
        <button id="otherLostPoint" class="action" data-action="その他失点">その他失点</button>
        <button id="otherPoint" class="action" data-action="その他得点">その他得点</button>
      </div>
    </section>
    
    <section id="logSection">
      <h2>アクションログ</h2>
      <div class="log-tabs">
        <button class="log-tab-btn active" data-tab="all">すべてのアクション</button>
        <button class="log-tab-btn" data-tab="point">得点変動のみ</button>
      </div>
      <div id="logControls" class="row">
        <button id="undo">直前を取り消す</button>
      </div>
      <ul id="log"></ul>
    </section>
  </main>

  <div id="modal" class="modal hidden" role="dialog">
    <div class="modal-content">
      <h3 id="modalTitle">アクション記録</h3>
      <form id="actionForm">
        <input type="hidden" name="action" id="modalAction" />
        <input type="hidden" name="type" id="modalType" />
        <div class="modal-form-row">
          <h4>実行プレイヤーを選択</h4>
          <div id="player-select-list" class="choice-list"></div>
        </div>
        <div class="modal-form-row">
          <h4>結果を選択</h4>
          <div id="result-select-list" class="choice-list"></div>
        </div>
        <div class="modal-form-row">
          <label for="actionMemoInput">メモ（任意）:</label>
          <input type="text" id="actionMemoInput" autocomplete="off" />
        </div>
      </form>
      <div class="modal-actions">
        <button id="modalCancel">キャンセル</button>
        <button id="modalConfirm">確定</button>
      </div>
    </div>
  </div>

  <div id="subModal" class="modal hidden" role="dialog">
    <div class="modal-content">
      <h3 id="subModalTitle">プレイヤー交代</h3>
      <form id="subForm">
        <div class="modal-form-row">
          <div>交代アウトするプレイヤー: <strong id="subOutPlayerName"></strong></div>
          <div style="margin-top:8px;">交代インするプレイヤーを選択してください:</div>
        </div>
        <div id="sub-player-select-list" class="choice-list"></div>
      </form>
      <div class="modal-actions">
        <button id="subModalCancel">キャンセル</button>
        <button id="subModalConfirm">交代確定</button>
      </div>
    </div>
  </div>

  <div id="memoModal" class="modal hidden" role="dialog">
    <div class="modal-content">
      <h3 id="memoModalTitle">メモ入力</h3>
      <div class="modal-form-row">
        <label for="memoInput">メモ（任意）:</label>
        <input type="text" id="memoInput" autocomplete="off" />
      </div>
      <div class="modal-actions">
        <button id="memoModalCancel">キャンセル</button>
        <button id="memoModalConfirm">確定</button>
      </div>
    </div>
  </div>

  <div id="exportModal" class="modal hidden" role="dialog">
    
    <div class="modal-content">
      <h3 id="exportModalTitle">集計結果・詳細</h3>
      <div id="exportInfo">
        <p></p>
      </div>
      <div id="exportSetScores">
    </div>
      <div id="export-set-tabs" class="set-tabs-container">
      </div>

      
      <div id="scoreGraphContainer">
        <h3>得点グラフ</h3>
        <div class="graph-viewport"></div>
      </div>
      <div id="exportScreen">
        <table id="exportTable"></table>
      </div>
      <div id="reflectionContainer">
        <h3>試合の反省・メモ</h3>
        <textarea id="matchReflection" placeholder="試合の反省点などを記録できます"></textarea>
      </div>
      <div class="modal-actions">
        <button id="downloadJsonButton">全データをJSON形式でダウンロード</button>
        <button id="downloadCsvButton">集計表をCSV形式でダウンロード</button>
        <button id="exportModalClose">閉じる</button>
      </div>
    </div>
  </div>

  <div id="logEditModal" class="modal hidden" role="dialog">
      <div class="modal-content">
          <h3 id="logEditModalTitle">アクション編集</h3>
          <form id="logEditForm">
              <input type="hidden" id="logEditOriginalIndex" /> <div class="modal-form-row">
                  <h4>アクションの種類</h4>
                  <div id="logEditActionType" style="font-weight: bold; margin-bottom: 8px;"></div>
              </div>

              <div class="modal-form-row" id="logEditPlayerRow">
                  <h4>実行プレイヤーを選択</h4>
                  <div id="logEdit-player-select-list" class="choice-list"></div>
              </div>
              
              <div class="modal-form-row" id="logEditResultRow">
                  <h4>結果を選択</h4>
                  <div id="logEdit-result-select-list" class="choice-list"></div>
              </div>
              
              <div class="modal-form-row">
                  <label for="logEditMemoInput">メモ（任意）:</label>
                  <input type="text" id="logEditMemoInput" autocomplete="off" />
              </div>
          </form>
          <div class="modal-actions">
              <button id="logEditDelete" style="background: #fdeeee; color: #9b2c2c;">このログを削除</button>
              <span style="flex-grow: 1;"></span>
              <button id="logEditCancel">キャンセル</button>
              <button id="logEditConfirm" class="action">変更確定</button>
          </div>
      </div>
  </div>

  <div id="newGameConfirmModal" class="modal hidden" role="dialog">
    <div class="modal-content" style="min-width: 280px; text-align: center;">
        <h3 style="margin-top: 0;">新規試合開始の確認</h3>
        <p>現在の記録はリセットされます。</p>
        <p>本当に新規試合を開始しますか？</p>
        <div class="modal-actions" style="justify-content: center;">
            <button id="newGameCancel">いいえ (キャンセル)</button>
            <button id="newGameConfirm" style="background: #ffeae9; color: rgb(0, 0, 0);">はい (開始)</button>
        </div>
    </div>
</div>
<div id="importJsonModal" class="modal hidden">
    <div class="modal-content" style="width: 90%; max-width: 500px;">
        <h3 style="margin-top: 5px; margin-bottom: 15px;">JSONデータからインポート</h3>
        <p style="font-size: 13px; color: #555;margin-bottom: 15px;line-height: 1.5;">エクスポートしたJSONファイルの中身をすべてコピーし、下の欄に貼り付けて「インポート」を押してください。
        </p>
        <textarea 
            id="importJsonTextarea" 
            rows="8" 
            placeholder="ここにJSONデータを貼り付け..."
            style="width: 100%; box-sizing: border-box; font-size: 13px; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
        </textarea>
        <div class="modal-actions" style="margin-top: 20px; grid-template-columns: 1fr 1fr;  gap: 10px;">
            <button id="importJsonModalClose" class="btn-secondary" style="border-color:#aeacac">キャンセル</button>
            <button id="executeImportButton" class="btn-primary" style="background-color: #d6f1ff;border-color: #94dafd;">インポート</button>
        </div>
    </div>
</div>

<script>
    // --- Global Variables/Helpers ---
    const $ = s => document.querySelector(s);
    const $$ = s => document.querySelectorAll(s);
    let currentMemoAction = null;
    let currentSubSlotIndex = null;
    let nextPlayerId = 1;
    let currentLogEditIndex = null;
    
    // exportViewingSetIndex の定義を修正: 
    // -1: 全体合算, 0: Set 1のみ, 1: Set 2のみ, ...
    let exportViewingSetIndex = -1; // 初期値は「全体」
    
    const ACTION_CONFIG = {
    POINT_ACTION: {
      actions: ['サーブ', 'スパイク'],
      results: [{ v: '得点', p: true, e: false }, { v: 'ミス', p: false, e: true }, { v: 'その他', p: false, e: false }]
    },
    BLOCK: {
      actions: ['ブロック'],
      results: [{ v: 'シャット', p: true, e: false }, { v: 'ミス', p: false, e: true }, { v: 'その他', p: false, e: false }]
    },
    SERVICE_RECEIVE: {
      actions: ['レセ'],
      results: [{ v: 'Sオーバー', p: false, e: false }, { v: 'Sアンダー', p: false, e: false }, { v: 'ミス', p: false, e: true }, { v: 'その他', p: false, e: false }]
    },
    DIG_RECEIVE: {
      actions: ['チャンス', 'ディグ'],
      results: [{ v: 'Sオーバー', p: false, e: false }, { v: 'Sアンダー', p: false, e: false }, { v: 'ミス', p: false, e: true }, { v: 'その他', p: false, e: false }]
    },
    SET: {
      actions: ['二段トス'],
      results: [{ v: '打つ', p: false, e: false }, { v: 'トス', p: false, e: false }, { v: 'ミス', p: false, e: true }, { v: 'その他', p: false, e: false }]
    }
  };

  function getActionResults(a) {
    for (const k in ACTION_CONFIG) {
      if (ACTION_CONFIG[k].actions.includes(a)) return ACTION_CONFIG[k].results.map(r => ({ ...r, value: r.v, isPoint: r.p, isError: r.e }));
    }
    return ACTION_CONFIG.POINT_ACTION.results.map(r => ({ ...r, value: r.v, isPoint: r.p, isError: r.e }));
  }

  function getScoreChanges(isP, isE, isOther) {
    let t = 0, o = 0;
    if (isOther) t = 1;
    else if (isP) t = 1;
    else if (isE) o = 1;
    return { teamPointChange: t, opponentPointChange: o };
  }

    // --- State & Set Management ---
    const state = {
        teamName: '自チーム',
        opponentName: '相手チーム',
        matchDate: Date.now(),
        onCourtSize: 7, // 6 or 7
        allPlayers: [], // { id, name, totalPoints(試合トータル), totalErrors(試合トータル) }
        onCourtPlayerIds: [], // コート上の選手ID
        
        activeSetIndex: 0, 
        viewingSetIndex: 0, 
        matchSets: [], 
    };

    function createNewSetData(setNum) {
        return {
            setNumber: setNum,
            log: [], 
            teamScore: 0,
            opponentScore: 0,
            reflection: '',
        };
    }

    function getActiveSet() {
        return state.matchSets[state.activeSetIndex];
    }
    
    function getViewingSet() {
        return state.matchSets[state.viewingSetIndex];
    }
    
    // --- Data Persistence ---
    const save = () => {
        const p = JSON.stringify({ 
            ...state, 
            log: undefined, 
            teamScore: undefined, 
            opponentScore: undefined, 
            reflection: undefined, 
            nextPlayerId: nextPlayerId
        });
        localStorage.setItem('vb_scorer_state', p);
    };

    const load = () => {
        const p = JSON.parse(localStorage.getItem('vb_scorer_state'));
        if (p) {
            // 基本情報のロード
            state.teamName = p.teamName || state.teamName;
            state.opponentName = p.opponentName || state.opponentName;
            state.matchDate = p.matchDate || state.matchDate;
            state.onCourtSize = p.onCourtSize || 7; 
            state.allPlayers = p.allPlayers || state.allPlayers;
            state.onCourtPlayerIds = p.onCourtPlayerIds || [];
            nextPlayerId = p.nextPlayerId || state.allPlayers.length + 1;

            // セットデータのロード
            state.matchSets = p.matchSets || [];
            if (state.matchSets.length === 0) {
                 // 旧バージョンからの移行処理（または空の場合の初期化）
                 if (p.log || p.teamScore || p.opponentScore) {
                    const set1 = createNewSetData(1);
                    set1.log = p.log || [];
                    set1.teamScore = p.teamScore || 0;
                    set1.opponentScore = p.opponentScore || 0;
                    set1.reflection = p.reflection || '';
                    state.matchSets.push(set1);
                 } else {
                    state.matchSets.push(createNewSetData(1));
                 }
            }
            
            state.activeSetIndex = p.activeSetIndex ?? state.matchSets.length - 1;
            state.viewingSetIndex = p.viewingSetIndex ?? state.activeSetIndex; 
            
            recomputeFromLog();
            
        } else {
            // 初回起動時: プレイヤー初期化をここで呼ぶ
            initPlayers(7, true); 
            state.matchSets = [createNewSetData(1)]; 
        }
    };
    
    // --- Core Functions ---
    function getPlayerById(id) {
        if (!id) return undefined;
        return state.allPlayers.find(x => x.id === id);
    }

    function escapeHtml(s) {
        if (s == null) return '';
        return String(s).replace(/[&<>"']/g, c => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[c]));
    }

    function getFormattedDate(t) {
        if (!t) return '--/--/-- (-)';
        try {
            const d = new Date(t);
            if (isNaN(d.getTime())) return '--/--/-- (-)';
            const y = String(d.getFullYear()).slice(-2),
                m = d.getMonth() + 1,
                day = d.getDate(),
                w = ['日', '月', '火', '水', '木', '金', '土'][d.getDay()];
            return `${y}/${m}/${day}(${w})`;
        } catch (e) {
            console.error("Date fail:", e);
            return '--/--/-- (-)';
        }
    }

    function autosizeTextarea(el) {
        el.style.height = 'auto';
        el.style.height = (el.scrollHeight) + 'px';
    }

    // --- Modals ---
    function showMemoModal(a) {
        currentMemoAction = a;
        $('#memoModalTitle').textContent = `${a} メモ`;
        $('#memoInput').value = '';
        $('#memoModal').classList.remove('hidden');
        $('#memoInput').focus();
    }

    function handleActionButton(e) {
        const act = e.currentTarget.dataset.action,
            type = e.currentTarget.dataset.type;

        if (!act) return; 
        
        if (act === 'その他失点' || act === 'その他得点') {
            showMemoModal(act);
            return;
        }
        
        const modal = $('#modal'),
            title = $('#modalTitle'),
            actIn = $('#modalAction'),
            typeIn = $('#modalType'),
            pList = $('#player-select-list'),
            rList = $('#result-select-list');
        
        title.textContent = `${act} 記録`;
        actIn.value = act;
        typeIn.value = type;
        $('#actionMemoInput').value = '';
        
        const onP = state.onCourtPlayerIds.map(id => getPlayerById(id)).filter(p => p);
        pList.innerHTML = onP.map(p => {
            const isL = state.onCourtSize === 7 && state.onCourtPlayerIds.indexOf(p.id) === 6,
                suf = isL ? ' (Li)' : '',
                name = p.name?.trim() || `ID:${p.id}`;
            return `<label class="choice-label"><input type="radio" name="playerId" value="${p.id}" required><span>${escapeHtml(name)}${suf}</span></label>`;
        }).join('');
        if (!pList.innerHTML) pList.innerHTML = '<p>選手なし</p>';
        
        // 外部定義の getActionResults を使用
        const res = getActionResults(act); 
        rList.innerHTML = res.map(r => `<label class="choice-label"><input type="radio" name="result" value="${r.v}" data-is-point="${r.p}" data-is-error="${r.e}" required><span>${escapeHtml(r.v)}</span></label>`).join('');
        modal.classList.remove('hidden');
    }

    $('#modalConfirm').onclick = () => {
        const form = $('#actionForm'),
            selP = form.querySelector('input[name="playerId"]:checked'),
            selR = form.querySelector('input[name="result"]:checked'),
            memoIn = $('#actionMemoInput');
        
        if (!selP) { alert('選手選択必須'); return; }
        if (!selR) { alert('結果選択必須'); return; }
        
        const pId = Number(selP.value),
            act = $('#modalAction').value,
            res = selR.value,
            isP = selR.dataset.isPoint === 'true',
            isE = selR.dataset.isError === 'true',
            memo = memoIn.value.trim();
            
        recordAction(pId, act, res, isP, isE, memo);
        $('#modal').classList.add('hidden');
        memoIn.value = '';
    };

    $('#modalCancel').onclick = () => {
        $('#modal').classList.add('hidden');
        $('#actionMemoInput').value = '';
    };
    
    function handleSubstitution(e) {
        const idx = Number(e.currentTarget.dataset.slotIndex);
        if (isNaN(idx) || idx < 0 || idx >= state.onCourtPlayerIds.length) {
            console.error("Invalid slot:", idx);
            return;
        }
        
        const outId = state.onCourtPlayerIds[idx],
            outP = getPlayerById(outId);
        if (!outP && outId !== 0) {
            console.warn(`Sub fail ID: ${outId}`);
            alert('交代アウト選手が見つかりません');
            return;
        }
        
        const outName = outP ? (outP.name.trim() || `ID:${outP.id}`) : '未設定';
        currentSubSlotIndex = idx;
        let slotN = `S${idx + 1}`;
        if (state.onCourtSize === 7 && idx === 6) slotN = 'リベロ枠';
        
        $('#subOutPlayerName').textContent = `${escapeHtml(outName)}(${slotN} OUT)`;
        
        const subList = $('#sub-player-select-list');
        subList.innerHTML = '';
        // 交代イン可能な選手: 全選手のうち、コート上にいない選手 (ID=0は除く)
        const avail = state.allPlayers.filter(p => p.id && !state.onCourtPlayerIds.includes(p.id));
        const opts = avail.map(p => {
            const name = p.name?.trim() || `ID:${p.id}`;
            return `<label class="choice-label"><input type="radio" name="subInPlayer" value="${p.id}" required><span>${escapeHtml(name)}</span></label>`;
        }).join('');
        
        subList.innerHTML = opts || '<p>交代選手なし</p>';
        $('#subModal').classList.remove('hidden');
    }

    $('#subModalConfirm').onclick = () => {
        const selIn = $('#sub-player-select-list input[name="subInPlayer"]:checked');
        if (!selIn || currentSubSlotIndex === null) {
            alert('交代イン選手を選択');
            return;
        }
        
        const newId = Number(selIn.value),
            oldId = state.onCourtPlayerIds[currentSubSlotIndex],
            newP = getPlayerById(newId);
            
        if (!newP) {
            console.error(`Sub fail new ID: ${newId}`);
            alert('交代イン選手情報なし');
            return;
        }
        
        state.onCourtPlayerIds[currentSubSlotIndex] = newId;
        
        const activeSet = getActiveSet();
        activeSet.log.push({
            time: Date.now(),
            type: 'sub',
            playerId: newId,
            slotIndex: currentSubSlotIndex,
            oldPlayerId: oldId,
            action: '交代',
            result: `S${currentSubSlotIndex + 1}に${escapeHtml(newP.name || `ID:${newP.id}`)} IN`
        });
        
        currentSubSlotIndex = null;
        save();
        renderAll();
        $('#subModal').classList.add('hidden');
    };

    $('#subModalCancel').onclick = () => {
        currentSubSlotIndex = null;
        $('#subModal').classList.add('hidden');
    };

    // --- Rendering ---
    function renderPartial() {
        renderLog();
        renderSetTabs(); 
    }
    
    function renderAll() {
        renderPlayers();
        renderAllPlayersList();
        renderSetTabs(); 
        renderLog();
    }
    
    // ★ 修正: タブのスコア表示は自動で最新化され、クリックしてもスコアは更新されないようにする
    function renderSetTabs() {
        const cont = $('#set-tabs');
        if (!cont) return;
        cont.innerHTML = '';
        
        state.matchSets.forEach((set, index) => {
            const btn = document.createElement('button');
            btn.classList.add('log-tab-btn', 'set-tab-btn');
            
            if (index === state.viewingSetIndex) {
                 btn.classList.add('active');
            } 
            if (index === state.activeSetIndex) {
                 btn.style.borderBottom = '2px solid orange'; 
                 btn.title = 'データ入力はここに記録されます';
            }
            
            const score = `${set.teamScore}-${set.opponentScore}`;
            // クリック時にスコアを更新する処理を削除し、常に最新のセットスコアを表示
            btn.textContent = `Set ${set.setNumber} (${score})`; 
            btn.dataset.setIndex = index;
            
            btn.onclick = (e) => {
                state.viewingSetIndex = Number(e.target.dataset.setIndex);
                renderSetTabs(); 
                renderLog(); 
                save(); 
            };
            cont.appendChild(btn);
        });

        const nextBtn = $('#nextSetButton');
        if (nextBtn) {
            if (state.matchSets.length >= 3) {
                nextBtn.textContent = '試合終了';
                nextBtn.disabled = true;
            } else {
                nextBtn.textContent = `次のセットへ (Set ${state.matchSets.length + 1})`;
                nextBtn.disabled = false;
            }
        }
    }

    function renderPlayers() {
        const cont = $('#players');
        cont.innerHTML = '';
        
        // onCourtPlayerIds の長さを onCourtSize に合わせる (念のため)
        while (state.onCourtPlayerIds.length < state.onCourtSize) {
              state.onCourtPlayerIds.push(0);
        }
        if (state.onCourtPlayerIds.length > state.onCourtSize) {
              state.onCourtPlayerIds.splice(state.onCourtSize);
        }
        
        for (let i = 0; i < state.onCourtSize; i++) {
            const pId = state.onCourtPlayerIds[i] || 0,
                p = getPlayerById(pId) || { id: 0, name: '未設定' },
                div = document.createElement('div');
                
            div.className = 'player';
            div.setAttribute('data-slot-index', i);
            div.setAttribute('data-player-id', p.id);
            
            const dispN = p.name?.trim() || (p.id ? `ID:${p.id}` : '未設定');
            // リベロ枠の表示は、7人制の最後のスロットに限定
            const slotN = (state.onCourtSize === 7 && i === 6) ? ' (Li)' : '';
                
            div.innerHTML = `<h3 title="${escapeHtml(dispN)} (S${i + 1})">${escapeHtml(dispN)}${slotN}</h3><button class="sub-btn" data-slot-index="${i}">交代</button>`;
            cont.appendChild(div);
        }
        $$('.sub-btn').forEach(b => {
            b.removeEventListener('click', handleSubstitution);
            b.addEventListener('click', handleSubstitution);
        });
    }

    function renderAllPlayersList() {
        const cont = $('#allPlayersList'),
            focusEl = document.activeElement,
            focusId = focusEl?.classList.contains('edit-player-name') ? focusEl.dataset.id : null,
            curPos = focusEl?.selectionStart;
            
        cont.innerHTML = '';
        state.allPlayers.forEach(p => {
            if (!p?.id) return;
            const div = document.createElement('div');
            div.className = 'player-register-row';
            const isOn = state.onCourtPlayerIds.includes(p.id);
            let status = '';
            if (isOn) {
                const idx = state.onCourtPlayerIds.indexOf(p.id);
                // リベロ表示は7人制の最後のスロットにいる選手のみ
                if (idx !== -1) status = (state.onCourtSize === 7 && idx === 6) ? '【Li】' : '【コート上】';
                else status = '【？】';
            }
            const rem = !isOn,
                name = p.name || '';
            div.innerHTML = `<input type="text" class="edit-player-name player-register-name-input" value="${escapeHtml(name)}" data-id="${p.id}" placeholder="名前" inputmode="text" autocomplete="off"><div style="width:70px;font-size:11px;align-self:center;text-align:right;color:${isOn ? '#2a66b9' : '#888'};">${status}</div><button class="remove-player-btn" data-id="${p.id}" ${rem ? '' : 'disabled'}>削除</button>`;
            cont.appendChild(div);
        });
        
        $$('.edit-player-name').forEach(el => {
            el.removeEventListener('input', handlePlayerNameEdit);
            el.addEventListener('input', handlePlayerNameEdit);
        });
        $$('.remove-player-btn').forEach(el => {
            el.removeEventListener('click', handleRemovePlayer);
            el.addEventListener('click', handleRemovePlayer);
        });
        
        if (focusId) {
            const newEl = $(`#allPlayersList input.edit-player-name[data-id="${focusId}"]`);
            if (newEl) {
                newEl.focus();
                if (curPos !== null) {
                    try { newEl.setSelectionRange(curPos, curPos); } catch (e) {}
                }
            }
        }
    }

    function handlePlayerNameEdit(e) {
        const id = Number(e.target.dataset.id),
            name = e.target.value,
            p = getPlayerById(id);
        if (p) {
            p.name = name;
            save();
            renderPlayers();
        }
    }

    function renderLog() {
        const ul = $('#log');
        ul.innerHTML = '';
        
        const viewingSet = getViewingSet();
        if (!viewingSet) return; 
        
        let scores = [], t = 0, o = 0;
        
        viewingSet.log.forEach(e => {
            const isO = e.action === 'その他得点',
                // 外部定義の getScoreChanges を使用
                sc = getScoreChanges(e.isPoint, e.isError, isO);
            t += sc.teamPointChange;
            o += sc.opponentPointChange;
            scores.push(e.type !== 'sub' ? `${t}-${o}` : null);
        });

        const logWithIndex = viewingSet.log.map((e, index) => ({
            ...e,
            originalIndex: index 
        }));

        const tab = $('.log-tab-btn:not(.set-tab-btn).active')?.dataset.tab || 'all';
        const revLog = logWithIndex.slice().reverse(); 
        
        for (const e of revLog) {
            const hasScore = e.type !== 'sub' && (e.isPoint || e.isError || e.action === 'その他得点' || e.action === 'その他失点');
            let display = true;
            if (tab === 'point' && !hasScore) display = false;
            
            if (display) {
                let text = '';
                if (e.type === 'sub') {
                    const p = getPlayerById(e.playerId),
                        name = p ? p.name.trim() || `ID:${p.id}` : '不明';
                    let slot = `S${e.slotIndex + 1}`;
                    if (state.onCourtSize === 7 && e.slotIndex === 6) slot = 'L';
                    text = `[換] ${slot} に ${name} IN`;
                } else {
                    const p = getPlayerById(e.playerId),
                        name = p ? (p.name.trim() || `ID:${p.id}`) : '--';
                    if (e.action === 'その他得点' || e.action === 'その他失点') {
                             text = `[${e.action}]`; 
                    } else {
                             text = `${name} [${e.action}] ${escapeHtml(e.result || '')}`; 
                    }
                    
                    const score = scores[e.originalIndex];
                    if (score && hasScore) text += ` (${score})`;
                }
                
                const li = document.createElement('li');
                
                li.setAttribute('data-original-index', e.originalIndex);
                li.setAttribute('data-set-index', state.viewingSetIndex); 
                
                if (e.memo) text += ` <span style="font-size:0.9em;color:#555;">(${escapeHtml(e.memo)})</span>`;
                li.innerHTML = text;
                ul.appendChild(li); 
            }
        }
    }

    // --- Player Management ---
    function handleAddPlayer() {
        const input = $('#newPlayerName'),
            name = input.value.trim();
        if (!name) { alert('名前入力必須'); input.focus(); return; }
        if (state.allPlayers.some(p => p.name === name)) { alert('同名選手あり'); input.focus(); return; }
        
        let newId = nextPlayerId;
        while (state.allPlayers.some(p => p.id === newId)) newId++;
        nextPlayerId = newId + 1;
        
        const newP = { id: newId, name: name, tP: 0, tE: 0 };
        state.allPlayers.push({ ...newP, totalPoints: 0, totalErrors: 0 });
        input.value = '';
        save();
        renderAll();
        $('#newPlayerName').focus();
    }

    function handleRemovePlayer(event) {
        const id = Number(event.currentTarget.dataset.id),
            pR = getPlayerById(id);
        if (!pR) { console.warn(`Cannot remove ID ${id}`); return; }
        if (state.onCourtPlayerIds.includes(id)) { alert('コート上の選手は削除不可'); return; }
        if (!confirm(`選手「${escapeHtml(pR.name || `ID:${id}`)}」削除しますか？`)) return;
        
        state.allPlayers = state.allPlayers.filter(p => p.id !== id);
        state.matchSets.forEach(set => {
            set.log.forEach(e => {
                if (e.playerId === id) e.playerId = null;
                if (e.oldPlayerId === id) e.oldPlayerId = null;
            });
        });

        recomputeFromLog(); 
        save();
        renderAll();
    }

    // initPlayers 関数 (デフォルトの選手名とコート上の初期配置を再設定)
    function initPlayers(size, isNewGame = false) {
        state.onCourtSize = size;
        
        // 新規ゲーム時、または全プレイヤーがいない場合、デフォルトプレイヤーを作成
        if (isNewGame || state.allPlayers.length === 0) {
            let initialCount = 0;
            if (size === 7) initialCount = 7; // 7人制（リベロ含む）
            else initialCount = 6; // 6人制
            
            // 既存の onCourtPlayerIds をリセット
            state.onCourtPlayerIds = [];
            
            for (let i = 0; i < initialCount; i++) {
                const defaultName = (size === 7 && i === 6) ? 'リベロ' : `名前${i + 1}`;
                
                // 既に登録されているかチェックし、いなければ新規作成
                let existingPlayer = state.allPlayers.find(p => p.name === defaultName);
                let pId;

                if (!existingPlayer) {
                    let newId = nextPlayerId;
                    while (state.allPlayers.some(p => p.id === newId)) newId++;
                    nextPlayerId = newId + 1;
                    
                    const newP = { id: newId, name: defaultName, totalPoints: 0, totalErrors: 0 };
                    state.allPlayers.push(newP);
                    pId = newId;
                } else {
                    pId = existingPlayer.id;
                }
                
                // コート上に配置
                state.onCourtPlayerIds.push(pId);
            }
            
            // onCourtPlayerIds の長さを onCourtSize に合わせる (念のため)
            if (state.onCourtPlayerIds.length > state.onCourtSize) {
                  state.onCourtPlayerIds.splice(state.onCourtSize);
            }
        } else {
            // 既存のプレイヤーがいる場合、コート上の人数だけを調整
              const currentSize = state.onCourtPlayerIds.length;
              if (size > currentSize) {
                // サイズ拡大: 新しい枠は 0 (未設定) で埋める
                for (let i = currentSize; i < size; i++) {
                    state.onCourtPlayerIds.push(0); 
                }
            } else if (size < currentSize) {
                // サイズ縮小: 余分な枠を削除
                state.onCourtPlayerIds.splice(size);
            }
        }
        
        save();
        renderPlayers(); 
    }


    // --- Scoring ---
    function recordOtherLostPoint(memo) {
        const activeSet = getActiveSet(); 
        let rT = state.opponentName + 'が得点';
        activeSet.log.push({ time: Date.now(), type: 'point', playerId: null, action: 'その他失点', result: rT, memo: memo || undefined, isPoint: false, isError: true, isOther: true });
        recomputeFromLog();
        save();
        renderLog();
        if (!$('#exportModal').classList.contains('hidden')) showExportScreen();
    }

    function recordOtherPoint(memo) {
        const activeSet = getActiveSet(); 
        let rT = state.teamName + 'が得点';
        activeSet.log.push({ time: Date.now(), type: 'point', playerId: null, action: 'その他得点', result: rT, memo: memo || undefined, isPoint: true, isError: false, isOther: true });
        recomputeFromLog();
        save();
        renderLog();
        if (!$('#exportModal').classList.contains('hidden')) showExportScreen();
    }

    function recordAction(pId, act, res, isP, isE, memo = '') {
        const activeSet = getActiveSet(); 
        const ev = { time: Date.now(), type: 'action', playerId: pId, action: act, result: res, isPoint: isP, isError: isE, memo: memo || undefined, isOther: false };
        activeSet.log.push(ev); 
        recomputeFromLog();
        save();
        renderLog();
        if (!$('#exportModal').classList.contains('hidden')) showExportScreen();
    }

    function recomputeFromLog() {
        state.allPlayers.forEach(p => { 
            if(p){ p.totalPoints = 0; p.totalErrors = 0; } 
        });
        
        for (const set of state.matchSets) {
            set.teamScore = 0; 
            set.opponentScore = 0;

            for (const e of set.log) { 
                if (e.type === 'action' || e.type === 'point') {
                    const isO = e.action === 'その他得点',
                        // 外部定義の getScoreChanges を使用
                        sc = getScoreChanges(e.isPoint, e.isError, isO);
                    set.teamScore += sc.teamPointChange; 
                    set.opponentScore += sc.opponentPointChange;

                    if (e.type === 'action' && e.playerId) {
                        const p = getPlayerById(e.playerId);
                        if (p) {
                            if (e.isPoint) p.totalPoints++; 
                            if (e.isError) p.totalErrors++;
                        }
                    }
                }
            }
        }
        renderSetTabs(); 
    }

    // --- Export ---
    // ★ setIndex: -1 (全セット合算), 0 (Set 1のみ), 1 (Set 2のみ), ...
    function tallyActionsByPlayer(setIndex) {
        // setIndexが -1 の場合は全セット、それ以外は指定されたインデックスのセットを対象とする
        const targetSets = setIndex === -1 ? state.matchSets : [state.matchSets[setIndex]].filter(s => s);
        
        if (typeof ACTION_CONFIG === 'undefined') {
            console.error("ACTION_CONFIG が定義されていません。");
            return { tallyData: [], actionResultsMap: {}, actionCategories: [] };
        }
        
        const dets = [], resMap = {};
        for (const k in ACTION_CONFIG) {
            ACTION_CONFIG[k].actions.forEach(a => {
                dets.push(a);
                ACTION_CONFIG[k].results.forEach(r => {
                    if (!resMap[a]) resMap[a] = new Set();
                    resMap[a].add(r.v);
                });
            });
        }
        
        const tally = new Map();
        state.allPlayers.forEach(p => {
            if (!p?.id) return;
            tally.set(p.id, {
                id: p.id,
                name: p.name?.trim() || `ID:${p.id}`,
                actions: dets.reduce((acc, a) => {
                    acc[a] = {};
                    Array.from(resMap[a] || []).forEach(r => { acc[a][r] = 0; });
                    return acc;
                }, {})
            });
        });
        
        targetSets.forEach(set => {
            set.log.forEach(e => {
                if (e.type === 'action' && e.playerId) {
                    const a = e.action,
                        r = e.result,
                        pT = tally.get(e.playerId);
                    if (pT?.actions[a]?.hasOwnProperty(r)) pT.actions[a][r]++;
                }
            });
        });
        
        return { tallyData: Array.from(tally.values()), actionResultsMap: resMap, actionCategories: dets };
    }

    // ★ setIndex の値に応じて対象セットを決定し、集計表を作成
    function buildExportTable(setIndex) {
        const tab = $('#exportTable'),
            { tallyData: data, actionResultsMap: resMap, actionCategories: cats } = tallyActionsByPlayer(setIndex);
            
        if (!cats.length) { tab.innerHTML = `<caption>集計</caption><tr><td>記録なし</td></tr>`; return; }
        
        let html = '<thead><tr><th rowspan="2">選手</th>', 
            subH = '<tr>'; 
            
        cats.forEach(a => {
            const res = Array.from(resMap[a] || []);
            if (res.length) {
                html += `<th colspan="${res.length + 1}">${escapeHtml(a)}</th>`; 
                
                subH += `<th class="opportunity-header">機会</th>`; 
                
                res.forEach((r, resIndex) => { 
                    const isLastCellOfCategory = (resIndex === res.length - 1);
                    const dividerClass = isLastCellOfCategory ? ' category-divider' : '';
                    subH += `<th class="${dividerClass}">${escapeHtml(r)}</th>`; 
                });
            }
        });
        html += `</tr>${subH}</tr></thead>`; 
        html += '<tbody>';
        
        // 表示対象の選手リストを生成（全セットのログに登場した選手 + コート上の選手）
        const actIds = new Set();
        // 対象セットの決定を修正: tallyActionsByPlayer と同じロジック
        const targetSets = setIndex === -1 ? state.matchSets : [state.matchSets[setIndex]].filter(s => s);
        
        targetSets.forEach(set => {
            set.log.filter(e => e.playerId).map(e => actIds.add(e.playerId));
        });
        state.onCourtPlayerIds.forEach(id => actIds.add(id));

        let hasD = false;
        
        data.filter(pD => actIds.has(pD.id)).forEach(pD => {
            hasD = true;
            let row = `<tr><td>${escapeHtml(pD.name)}</td>`; 
            
            cats.forEach(a => {
                const res = Array.from(resMap[a] || []);
                
                const opportunityCount = pD.actions[a] ? Object.values(pD.actions[a]).reduce((sum, count) => sum + (count || 0), 0) : 0;
                
                row += `<td class="opportunity-cell">${opportunityCount || ''}</td>`;
                
                res.forEach((r, resIndex) => {
                    const cnt = pD.actions[a] ? (pD.actions[a][r] || 0) : 0;
                    
                    const isLastCellOfCategory = (resIndex === res.length - 1);
                    const dividerClass = isLastCellOfCategory ? ' category-divider' : '';
                    
                    row += `<td class="${dividerClass}">${cnt || ''}</td>`;
                });
            });
            row += '</tr>';
            html += row;
        });
        
        html += '</tbody>';
        if (!hasD) { tab.innerHTML = `<caption>集計</caption><tr><td>対象選手記録なし</td></tr>`; return; }
        tab.innerHTML = html;
    }

    // ★ setIndex の値に応じて対象セットを決定し、グラフを作成
    function renderScoreGraph(setIndex) {
        const contContainer = $('#scoreGraphContainer');
        const cont = $('#scoreGraphContainer .graph-viewport');
        if (!contContainer || !cont) return;

        // 【NEW】合算表示（-1）の場合はグラフ全体を非表示にする
        if (setIndex === -1) {
            contContainer.style.display = 'none';
            return;
        }

        contContainer.style.display = 'block'; // セット表示の場合は表示する
        cont.innerHTML = '';
        
        let allScoreEvents = [];
        
        // 対象セットの決定を修正: setIndexが -1 の場合は全セット、それ以外は指定されたインデックスのセット
        const targetSets = setIndex === -1 ? state.matchSets : [state.matchSets[setIndex]].filter(s => s);
        
        let tS = 0, oS = 0;
        
        targetSets.forEach((set, idx) => {
            // セットが切り替わるときはスコアをリセット (全体表示でない場合)
            if (setIndex !== -1) { tS = 0; oS = 0; } 
            
            set.log.forEach(e => {
                // 外部定義の getScoreChanges を使用
                if (e.type !== 'sub' && (getScoreChanges(e.isPoint, e.isError, e.action === 'その他得点').teamPointChange > 0 || getScoreChanges(e.isPoint, e.isError, e.action === 'その他得点').opponentPointChange > 0)) {
                    
                    const isO = e.action === 'その他得点',
                        sc = getScoreChanges(e.isPoint, e.isError, isO);
                        
                    let team = null, pVal = 0, log = '';
                    
                    if (sc.teamPointChange > 0) { team = 'team'; tS++; pVal = tS; } 
                    else if (sc.opponentPointChange > 0) { team = 'opponent'; oS++; pVal = oS; }

                    if (team) {
                        if (e.type === 'action') {
                            const p = getPlayerById(e.playerId),
                                name = p ? (p.name || `ID:${p.id}`) : '';
                            log = `${escapeHtml(name)}<br>${escapeHtml(e.action)}`; 
                        } else { 
                            log = 'その他'; 
                        }
                        if (e.memo) { log += `<br>(${escapeHtml(e.memo)})`; } 

                        const col = document.createElement('div');
                        col.classList.add('graph-column');
                        col.setAttribute('title', `Set ${set.setNumber}`); 
                        
                        const logT = document.createElement('div');
                        logT.classList.add('graph-log', 'log-top');
                        const pTA = document.createElement('div');
                        pTA.classList.add('graph-point-area');
                        const pBA = document.createElement('div');
                        pBA.classList.add('graph-point-area');
                        const logB = document.createElement('div');
                        logB.classList.add('graph-log', 'log-bottom');
                        
                        if (team === 'team') {
                            logT.innerHTML = log;
                            const pDiv = document.createElement('div');
                            pDiv.classList.add('graph-point', 'team');
                            pDiv.textContent = pVal;
                            pTA.appendChild(pDiv);
                        } else {
                            logB.innerHTML = log;
                            const pDiv = document.createElement('div');
                            pDiv.classList.add('graph-point', 'opponent');
                            pDiv.textContent = pVal;
                            pBA.appendChild(pDiv);
                        }
                        col.appendChild(logT);
                        col.appendChild(pTA);
                        col.appendChild(pBA);
                        col.appendChild(logB);

                        allScoreEvents.push(col);
                    }
                }
            });
        });
        
        // グラフのレンダリングロジック
        const columnsPerRow = 26; 
        let currentRowDiv = null;
        let currentColumnCount = 0;

        allScoreEvents.forEach(col => {
            if (currentColumnCount === 0 || currentColumnCount >= columnsPerRow) {
                currentRowDiv = document.createElement('div');
                currentRowDiv.classList.add('graph-row');
                cont.appendChild(currentRowDiv);
                currentColumnCount = 0;
            }
            currentRowDiv.appendChild(col);
            currentColumnCount++;
        });
        
        if (!allScoreEvents.length) cont.innerHTML = '<p style="font-size:12px;color:#888;padding:5px;">得点記録なし</p>';
    }

    function updateExportInfo() {
    const dateString = getFormattedDate(state.matchDate);
    
    // スコア情報は含めない
    const setString = `全${state.matchSets.length}セット`; 
    const opponentNameString = state.opponentName ? `(vs ${escapeHtml(state.opponentName)})` : '';
    
    // 【修正】表示内容を「日付」「全Nセット」「(vs 相手チーム)」に限定
    const infoText = `${dateString} ${setString} ${opponentNameString}`.trim();
    const exportInfoP = $('#exportInfo p');
    if (exportInfoP) exportInfoP.textContent = infoText;

    // セット別スコア表示欄をクリア
    const setScoresDiv = $('#exportSetScores');
    if (setScoresDiv) setScoresDiv.innerHTML = '';
}

    // ★ 修正: エクスポート画面にセット切り替えタブを追加し、表示を制御
    function showExportScreen() {
    // 【NEW】エクスポート画面を開いた際、表示対象を最新セットに設定する
    // ただし、もし既にセット別（0以上）が表示されていれば維持する
    if (exportViewingSetIndex === -1) {
        // アクティブセットのインデックス（配列インデックス）
        exportViewingSetIndex = state.activeSetIndex; 
    }
    
    updateExportInfo();
    
    // エクスポート画面用のセットタブをレンダリング
    renderExportSetTabs(); 
    
    // 現在選択中のセット（アクティブセット）のデータを表示
    const setIndex = exportViewingSetIndex; 
    
    // 合算表示でない（最新セットが表示される）ため、グラフが表示される
    renderScoreGraph(setIndex); 
    buildExportTable(setIndex);

        
        // 反省テキストエリアは「全体」タブ選択時はアクティブセットのもの、セット別選択時はそのセットのものにバインド
        const refTA = $('#matchReflection');
        const viewingSet = setIndex === -1 ? getActiveSet() : state.matchSets[setIndex];
        refTA.value = viewingSet ? viewingSet.reflection : ''; 
        refTA.removeEventListener('input', handleReflectionInput);
        refTA.addEventListener('input', handleReflectionInput);
        autosizeTextarea(refTA);
        
        $('#exportModal').classList.remove('hidden');
        $('#exportModal .modal-content').scrollTop = 0;
    }

    // ★ NEW: エクスポート画面用のセットタブのレンダリング (全体タブを常に含める)
    function renderExportSetTabs() {
        const cont = $('#export-set-tabs');
        if (!cont) return;
        cont.innerHTML = '';
        
        // --- 1. 「全体」タブ ---
        const allBtn = document.createElement('button');
        allBtn.classList.add('log-tab-btn', 'export-set-tab-btn');
        allBtn.textContent = '全体 (合算)';
        allBtn.dataset.setIndex = -1; // -1 は全体合算を表す
        if (exportViewingSetIndex === -1) allBtn.classList.add('active');
        allBtn.onclick = handleExportSetTabClick;
        cont.appendChild(allBtn);
        
        // --- 2. 各セットのタブ ---
        state.matchSets.forEach((set, index) => {
            const btn = document.createElement('button');
            btn.classList.add('log-tab-btn', 'export-set-tab-btn');
            const score = `${set.teamScore}-${set.opponentScore}`;
            // setIndex は 0, 1, 2, ... とセットの配列インデックスを使う
            btn.textContent = `Set ${set.setNumber} のみ (${score})`;
            btn.dataset.setIndex = index;
            if (index === exportViewingSetIndex) btn.classList.add('active');
            
            btn.onclick = handleExportSetTabClick;
            cont.appendChild(btn);
        });
    }

    // ★ NEW: エクスポート画面のセットタブクリック処理
    function handleExportSetTabClick(e) {
        const newIndex = Number(e.target.dataset.setIndex);
        exportViewingSetIndex = newIndex;
        
        // アクティブなタブを切り替える
        $$('.export-set-tab-btn').forEach(b => b.classList.remove('active'));
        e.target.classList.add('active');
        
        // データとグラフを更新
        renderScoreGraph(newIndex);
        buildExportTable(newIndex);
        
        // 反省テキストエリアも切り替える
        const refTA = $('#matchReflection');
        // 「全体」タブが選ばれた場合、アクティブセットの反省を見る
        const viewingSet = newIndex === -1 ? getActiveSet() : state.matchSets[newIndex];
        refTA.value = viewingSet ? viewingSet.reflection : '';
        autosizeTextarea(refTA);
    }
    
    function handleReflectionInput(e) {
        // 「全体」タブ選択時（-1）は、現在入力中のセット（activeSetIndex）に保存
        const setIndex = exportViewingSetIndex === -1 ? state.activeSetIndex : exportViewingSetIndex;
        const targetSet = state.matchSets[setIndex];
        if (targetSet) targetSet.reflection = e.target.value; 
        autosizeTextarea(e.target);
        save();
    }
    
   // --- Set Navigation ---
    function handleNextSet() {
        if (state.matchSets.length >= 3) return; 

        const modal = $('#nextSetConfirmModal');
        if (!modal) {
            console.error('#nextSetConfirmModal が見つかりません。HTMLに追加してください。');
            // (HTMLがない場合のフォールバック)
            if (!confirm(`次のセット（Set ${state.matchSets.length + 1}）に進みますか？`)) {
                return;
            } else {
                // フォールバックでOKが押された場合（モーダルがない場合）の処理
                const newSet = createNewSetData(state.matchSets.length + 1);
                state.matchSets.push(newSet);
                state.activeSetIndex = state.matchSets.length - 1;
                state.viewingSetIndex = state.activeSetIndex; 
                recomputeFromLog(); 
                save();
                renderAll();
                return;
            }
        }
        
        // モーダル内のメッセージを更新
        const msgEl = $('#nextSetConfirmMessage'); 
        if (msgEl) {
            msgEl.textContent = `次のセット（Set ${state.matchSets.length + 1}）に進みますか？`;
        }
        
        // ★重要★ モーダルを表示するだけで、ここではセットを進めない
        modal.classList.remove('hidden');
    }

/**
 * 試合の全データ（stateオブジェクト全体）をJSONファイルとしてダウンロードさせる関数
 */
function downloadFullDataJSON() {
    // 1. ダウンロードしたいデータ（save() と同じ構造）をJSON文字列に変換
    const dataToExport = {
        ...state,
        // state に含まれないグローバル変数を追加
        nextPlayerId: nextPlayerId 
    };
    
    const jsonData = JSON.stringify(dataToExport, null, 2); 
    
    // 2. Blob（バイナリラージオブジェクト）を作成
    const blob = new Blob([jsonData], { type: 'application/json;charset=utf-8;' });
    
    // 3. ダウンロード用のファイル名を設定
    // ファイル名例: VolleyLog_20251102_vs_相手チーム名.json
    const dateStr = getFormattedDate(state.matchDate).replace(/[^0-9]/g, '');
    const opponent = (state.opponentName || 'opponent').replace(/[^a-zA-Z0-9\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/g, '_'); // 日本語も考慮
    const filename = `VolleyLog_${dateStr}_vs_${opponent}.json`;

    // 4. ダウンロード処理を実行
    if (navigator.msSaveBlob) {
        // IE 10+ の場合
        navigator.msSaveBlob(blob, filename);
    } else {
        // 標準的なブラウザの場合
        const link = document.createElement('a');
        const url = URL.createObjectURL(blob);
        
        link.setAttribute('href', url);
        link.setAttribute('download', filename);
        link.style.visibility = 'hidden';

        document.body.appendChild(link);
        link.click();
        
        document.body.removeChild(link);
        URL.revokeObjectURL(url); // メモリ解放
    }
}
function downloadExportTableCSV() {
    const table = document.getElementById('exportTable');
    if (!table) {
        alert('集計表が見つかりません。');
        return;
    }

    let csv = [];
    
    // 1. ヘッダー行を処理し、1行の統合ヘッダーを作成
    const headerRows = table.querySelectorAll('thead tr');
    
    if (headerRows.length < 2) {
        // ヘッダーが1行の場合（処理を簡略化）
        const singleHeaderRow = [];
        headerRows[0].querySelectorAll('th').forEach(th => {
            let text = th.textContent.replace(/\s+/g, ' ').trim();
            singleHeaderRow.push(`"${text}"`);
        });
        csv.push(singleHeaderRow.join(','));
    } else {
        // 多段ヘッダー（2行）の場合の処理
        const mainActions = headerRows[0].querySelectorAll('th'); // サーブ, スパイク, ...
        const subItems = headerRows[1].querySelectorAll('th'); // 機会, 得点, ミス, ...
        
        let combinedHeader = [];
        let subItemIndex = 0;

        // 選手名の列（最初のth）を特別に追加
        const playerHeader = mainActions[0] ? mainActions[0].textContent.replace(/\s+/g, ' ').trim() : '';
        combinedHeader.push(`"${playerHeader}"`);

        // 2行目以降のメインアクション（サーブ、スパイクなど）を処理
        // 最初のthは選手名なのでスキップ
        for (let i = 1; i < mainActions.length; i++) {
            const actionTh = mainActions[i];
            const actionName = actionTh.textContent.replace(/\s+/g, ' ').trim();
            // colspanを取得（結合セルの数）
            const colspan = parseInt(actionTh.getAttribute('colspan') || '1'); 

            // colspanの数だけ、対応する2行目のサブアイテムと結合
            for (let j = 0; j < colspan; j++) {
                const subItemTh = subItems[subItemIndex];
                if (subItemTh) {
                    const subItemName = subItemTh.textContent.replace(/\s+/g, ' ').trim();
                    // アクション名 + サブ項目名で新しいヘッダーを作成
                    combinedHeader.push(`"${actionName} ${subItemName}"`);
                }
                subItemIndex++;
            }
        }
        csv.push(combinedHeader.join(','));
    }

    // --- 2. ボディ（データ）行の抽出 (ここは変更なし) ---
    const dataRows = table.querySelectorAll('tbody tr');
    dataRows.forEach(row => {
        const rowData = [];
        row.querySelectorAll('td').forEach(td => {
            let text = td.textContent.replace(/\s+/g, ' ').trim();
            rowData.push(`"${text}"`);
        });
        csv.push(rowData.join(','));
    });
    // --------------------------------------------------

    const csvString = csv.join('\n');

    // 3. ファイル名とBlobの準備 (変更なし)
    const dateStr = getFormattedDate(state.matchDate).replace(/[^0-9]/g, '');
    const opponent = state.opponentName.replace(/[^a-zA-Z0-9\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/g, '_');
    
    // 現在表示中のセットをファイル名に含める
    const setLabel = exportViewingSetIndex === -1 ? 'AllSets' : `Set${state.matchSets[exportViewingSetIndex]?.setNumber || 'Unknown'}`;
    
    const filename = `VolleyStats_${setLabel}_${dateStr}_vs_${opponent}.csv`;

    // CSVの文字化けを防ぐためBOM（Byte Order Mark）を付与
    const bom = new Uint8Array([0xef, 0xbb, 0xbf]);
    const blob = new Blob([bom, csvString], { type: 'text/csv;charset=utf-8;' });

    // 4. ダウンロード処理を実行 (変更なし)
    if (navigator.msSaveBlob) {
        navigator.msSaveBlob(blob, filename);
    } else {
        const link = document.createElement('a');
        const url = URL.createObjectURL(blob);
        
        link.setAttribute('href', url);
        link.setAttribute('download', filename);
        link.style.visibility = 'hidden';

        document.body.appendChild(link);
        link.click();
        
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
    }
}
/**
 * ★ 2. importDataFromJSON をこの関数に置き換え ★
 * JSONテキストを読み込んでアプリの状態を復元する関数
 * (テキストエリアからのペーストを想定)
 * @param {string} jsonText - インポートするJSONデータ文字列
 */
function importFromText(jsonText) {
    try {
        const p = JSON.parse(jsonText); // p (importedData)

        // --- データの検証 ---
        if (!p || typeof p.teamName === 'undefined' || !Array.isArray(p.allPlayers)) {
            alert('読み込まれたデータは、有効なVolleyLogデータ形式ではありません。');
            return false; // 失敗
        }

        // confirm() はGoogleサイトで動作しない可能性があるため、alert() で代用
        alert('現在のデータを上書きし、インポートを実行します。');


        // --- データの反映 (load() 関数のロジックを流用) ---
        
        // 1. 基本情報のロード
        state.teamName = p.teamName || state.teamName;
        state.opponentName = p.opponentName || state.opponentName;
        state.matchDate = p.matchDate || state.matchDate;
        state.onCourtSize = p.onCourtSize || 7; 
        state.allPlayers = p.allPlayers || state.allPlayers;
        state.onCourtPlayerIds = p.onCourtPlayerIds || [];
        nextPlayerId = p.nextPlayerId || state.allPlayers.length + 1;

        // 2. セットデータのロード
        state.matchSets = p.matchSets || [];
        if (state.matchSets.length === 0) {
            if (p.log || p.teamScore || p.opponentScore) {
                const set1 = createNewSetData(1);
                set1.log = p.log || [];
                set1.teamScore = p.teamScore || 0;
                set1.opponentScore = p.opponentScore || 0;
                set1.reflection = p.reflection || '';
                state.matchSets.push(set1);
            } else {
                state.matchSets.push(createNewSetData(1));
            }
        }
        
        // 3. インデックスの復元
        state.activeSetIndex = p.activeSetIndex ?? state.matchSets.length - 1;
        state.viewingSetIndex = p.viewingSetIndex ?? state.activeSetIndex; 
        
        // 4. ログからスコアや選手データを再計算
        recomputeFromLog();
        
        // 5. 新しいデータを localStorage に保存
        save();
        
        // 6. UIを更新
        const libSel = $('#liberoStatus');
        if (libSel) libSel.value = String(state.onCourtSize || 7);
        if ($('#opponentName')) $('#opponentName').value = state.opponentName || '相手チーム';
        renderAll(); 
        if (!$('#exportModal').classList.contains('hidden')) showExportScreen();

        alert('データのインポートが完了しました。');
        return true; // 成功
        
    } catch (error) {
        console.error('JSON解析エラー:', error);
        alert('データの読み込み中にエラーが発生しました。貼り付けたデータが破損しているか、JSON形式が正しくありません。');
        return false; // 失敗
    }
}
    // --- Init ---
    function initUI() {
        load();

        const libSel = $('#liberoStatus');
        libSel.value = String(state.onCourtSize || 7);
        $('#opponentName').value = state.opponentName || '相手チーム';
        
        libSel.onchange = (e) => {
            const nS = Number(e.target.value);
            if (nS !== state.onCourtSize) {
                // サイズ変更時、ログがある場合は警告するが、選手リストはリセットしない
                if (state.matchSets.some(set => set.log.length > 0) && !confirm('サイズを変更しますが、よろしいですか？（コート上のポジションは再配置されます）')) {
                    e.target.value = String(state.onCourtSize);
                    return;
                }
                
                // initPlayers の呼び出し (サイズ変更時は isNewGame=false で呼ぶ)
                initPlayers(nS, false); 
                save();
                renderAll();
            }
        };

        const newGameBtn = $('#newGame');
        const newGameModal = $('#newGameConfirmModal');
        const newGameConfirmBtn = $('#newGameConfirm');
        const newGameCancelBtn = $('#newGameCancel');

        newGameBtn.onclick = () => {
            newGameModal.classList.remove('hidden');
        };

        newGameConfirmBtn.onclick = () => {
            newGameModal.classList.add('hidden'); 
            
            state.activeSetIndex = 0;
            state.viewingSetIndex = 0;
            state.matchSets = [createNewSetData(1)];
            
            // 新規ゲーム開始時: プレイヤーリストとコートを初期化
            state.allPlayers = []; 
            initPlayers(state.onCourtSize, true); // trueで初期プレイヤーを再生成

            state.allPlayers.forEach(p => {
                p.totalPoints = 0;
                p.totalErrors = 0; 
            });
            
            // ★ 初期セット表示をリセット
            exportViewingSetIndex = -1; 
            
            save();
            renderAll();
        };

        newGameCancelBtn.onclick = () => {
            newGameModal.classList.add('hidden'); 
        };
const nextSetModal = $('#nextSetConfirmModal');
        const nextSetConfirmBtn = $('#nextSetConfirm'); // <button id="nextSetConfirm">
        const nextSetCancelBtn = $('#nextSetCancel');   // <button id="nextSetCancel">

        if (nextSetModal && nextSetConfirmBtn && nextSetCancelBtn) {
            nextSetConfirmBtn.onclick = () => {
                nextSetModal.classList.add('hidden');
                
                // handleNextSet から移動させた処理 (confirm() が true だった場合の処理)
                if (state.matchSets.length >= 3) return; // 念のため再チェック

                const newSet = createNewSetData(state.matchSets.length + 1);
                state.matchSets.push(newSet);
                
                state.activeSetIndex = state.matchSets.length - 1;
                state.viewingSetIndex = state.activeSetIndex; 

                recomputeFromLog(); 
                save();
                renderAll();
            };

            nextSetCancelBtn.onclick = () => {
                nextSetModal.classList.add('hidden');
            };
        }
        if ($('#showExportScreen')) $('#showExportScreen').onclick = showExportScreen;
    if ($('#exportModalClose')) $('#exportModalClose').onclick = () => {
        if ($('#exportModal')) $('#exportModal').classList.add('hidden');
    };
    
    // 【NEW】JSONダウンロードボタンにイベントリスナーを設定
    if ($('#downloadJsonButton')) {
        $('#downloadJsonButton').onclick = downloadFullDataJSON;
    }
    // --- ここから修正・追加 ---
    
    // ★ 3. 既存のインポートボタンの処理を修正 ★
    // (ボタンのIDが #importJsonButton ではない場合は、セレクタを修正してください)
    const existingImportButton = $('#importJsonButton'); 
    const importJsonModal = $('#importJsonModal');

    if (existingImportButton && importJsonModal) {
        // 「すでにあるインポートボタン」が押されたら、ファイル選択(click())ではなくモーダルを開く
        existingImportButton.onclick = () => {
            $('#importJsonTextarea').value = ''; // テキストエリアをクリア
            importJsonModal.classList.remove('hidden'); // モーダルを表示
            $('#importJsonTextarea').focus();
        };
    }
    
    // (もし #importJsonInput (type=file) があれば、それはもう不要です)
    // const importInput = $('#importJsonInput');
    // if (importInput) { ... } // ← このブロックは削除してOK
    

    // ★ 4. 新しいモーダル内のボタン処理を追加 ★
    const executeImportBtn = $('#executeImportButton');
    const importJsonModalClose = $('#importJsonModalClose');
    
    if (executeImportBtn && importJsonModalClose && importJsonModal) {
    
        // 「インポート実行」ボタンの処理
        executeImportBtn.onclick = () => {
            const jsonText = $('#importJsonTextarea').value;
            if (!jsonText || jsonText.trim() === '') {
                alert('JSONデータを貼り付けてください。');
                $('#importJsonTextarea').focus();
                return;
            }
            // 置き換えた importFromText 関数を呼び出す
            const success = importFromText(jsonText);
            
            if (success) {
                // インポート成功時のみモーダルを閉じる
                importJsonModal.classList.add('hidden');
            }
        };
        
        // 「キャンセル」ボタンの処理
        importJsonModalClose.onclick = () => {
            importJsonModal.classList.add('hidden');
        };
    }
    if ($('#downloadCsvButton')) {
        $('#downloadCsvButton').onclick = downloadExportTableCSV;
    }
        const nextSetBtn = $('#nextSetButton');
        if (nextSetBtn) nextSetBtn.onclick = handleNextSet; 

        $('#opponentName').oninput = (e) => {
            state.opponentName = e.target.value;
            save();
            if (!$('#exportModal').classList.contains('hidden')) updateExportInfo();
        };

        $('#addPlayer').onclick = handleAddPlayer;

        $('#undo').onclick = () => {
            const activeSet = getActiveSet();
            if (!activeSet?.log.length) { alert('取消不可'); return; }
            activeSet.log.pop();
            recomputeFromLog();
            save();
            renderAll();
            if (!$('#exportModal').classList.contains('hidden')) showExportScreen();
        };


        $$('.action').forEach(b => { b.onclick = handleActionButton; });

        $$('.log-tab-btn:not(.set-tab-btn)').forEach(btn => {
            btn.onclick = (e) => {
                $$('.log-tab-btn:not(.set-tab-btn)').forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
                renderLog();
            };
        });
        
        // --- Log Event Delegation (ログ編集の呼び出し) ---
        $('#log').addEventListener('click', (e) => {
            const li = e.target.closest('li');
            if (!li) return;
            
            const index = li.getAttribute('data-original-index');
            const setIndex = li.getAttribute('data-set-index'); 
            
            if (index === null || setIndex === null) return; 
            
            const originalIndex = Number(index);
            const targetSetIndex = Number(setIndex);

            if (targetSetIndex !== state.activeSetIndex) {
                alert('編集できるのは、現在入力中のセットのログのみです。');
                return;
            }
            
            const logEntry = state.matchSets[targetSetIndex].log[originalIndex];
            
            if (logEntry?.type === 'sub') {
                alert('交代ログは編集できません。');
                return;
            }
            
            showLogEditModal(originalIndex); 
        });
        // ----------------------------------------------------

        $('#memoModalCancel').onclick = () => {
            $('#memoModal').classList.add('hidden');
            currentMemoAction = null;
        };

        $('#memoModalConfirm').onclick = () => {
            const memo = $('#memoInput').value.trim();
            if (currentMemoAction === 'その他得点') recordOtherPoint(memo);
            else if (currentMemoAction === 'その他失点') recordOtherLostPoint(memo);
            $('#memoModal').classList.add('hidden');
            currentMemoAction = null;
        };

        const refTA = $('#matchReflection');
        refTA.addEventListener('input', () => autosizeTextarea(refTA));
        setTimeout(() => autosizeTextarea(refTA), 50);

        renderAll();

    // ログ編集モーダル関連関数 
    function showLogEditModal(originalIndex) {
        const activeSet = getActiveSet();
        const ev = activeSet.log[originalIndex];

        if (!ev || ev.type === 'sub') {
            alert('このログは編集できません。');
            return;
        }
        
        currentLogEditIndex = originalIndex;
        currentMemoAction = null;
        
        const modal = $('#logEditModal');
        const actionTypeDiv = $('#logEditActionType');
        const pList = $('#logEdit-player-select-list');
        const rList = $('#logEdit-result-select-list');
        
        const isOtherPointAction = ev.action === 'その他得点' || ev.action === 'その他失点';

        $('#logEditModalTitle').textContent = `Set ${activeSet.setNumber} アクション編集 (#${activeSet.log.length - originalIndex})`;
        actionTypeDiv.textContent = `${ev.action} (${isOtherPointAction ? '共通' : '個人'})`;

        $('#logEditPlayerRow').style.display = 'block';
        
        const onP = state.allPlayers.filter(p => p.id); 
        pList.innerHTML = onP.map(p => {
            const isL = state.onCourtSize === 7 && state.onCourtPlayerIds.indexOf(p.id) === 6; 
            const suf = isL ? ' (Li)' : '';
            const name = p.name?.trim() || `ID:${p.id}`;
            const checked = p.id === ev.playerId ? 'checked' : '';
            return `<label class="choice-label"><input type="radio" name="logEditPlayerId" value="${p.id}" ${checked}><span>${escapeHtml(name)}${suf}</span></label>`;
        }).join('');
        
        if (isOtherPointAction) {
            const isUnchecked = ev.playerId === null || ev.playerId === undefined ? 'checked' : '';
            pList.innerHTML = `<label class="choice-label" style="background:#fdeeee;"><input type="radio" name="logEditPlayerId" value="0" ${isUnchecked}><span>選手を特定しない (共通得点)</span></label>` + pList.innerHTML;
        }
        if (!pList.innerHTML) pList.innerHTML = '<p>選手なし</p>';


        if (ev.type === 'action' && !isOtherPointAction) {
            $('#logEditResultRow').style.display = 'block';
            // 外部定義の getActionResults を使用
            const res = getActionResults(ev.action);
            rList.innerHTML = res.map(r => {
                const checked = r.v === ev.result ? 'checked' : '';
                return `<label class="choice-label"><input type="radio" name="logEditResult" value="${r.v}" data-is-point="${r.p}" data-is-error="${r.e}" ${checked}><span>${escapeHtml(r.v)}</span></label>`;
            }).join('');
        } else {
            $('#logEditResultRow').style.display = 'none'; 
        }

        $('#logEditMemoInput').value = ev.memo || '';
        $('#logEditOriginalIndex').value = originalIndex; 
        
        modal.classList.remove('hidden');
    }


    // --- ログ編集イベントハンドラ (initUI関数内) ---

    $('#logEditCancel').onclick = () => {
        $('#logEditModal').classList.add('hidden');
        currentLogEditIndex = null;
        currentMemoAction = null; 
    };

    $('#logEditConfirm').onclick = () => {
        const originalIndex = Number($('#logEditOriginalIndex').value);
        const activeSet = getActiveSet(); 
        const ev = activeSet.log[originalIndex];
        if (!ev || ev.type === 'sub') { return; }

        let updatedEv = { ...ev };

        const form = $('#logEditForm');
        const selP = form.querySelector('input[name="logEditPlayerId"]:checked');
        const selR = form.querySelector('input[name="logEditResult"]:checked');
        const memo = $('#logEditMemoInput').value.trim();

        const isCommonAction = updatedEv.isOther;
        
        if (ev.type === 'action' && !isCommonAction && !selP) { alert('選手選択必須'); return; }
        // isCommonAction の場合、selRは存在しない（非表示）ためチェックをスキップ
        if (ev.type === 'action' && !isCommonAction && !selR) { alert('結果選択必須'); return; }

        if (selP) {
             updatedEv.playerId = Number(selP.value);
        } else if (isCommonAction) {
             updatedEv.playerId = (selP?.value === "0" || !selP) ? null : Number(selP?.value);
        }

        if (selR) {
             updatedEv.result = selR.value;
             updatedEv.isPoint = selR.dataset.isPoint === 'true';
             updatedEv.isError = selR.dataset.isError === 'true';
        } 

        updatedEv.memo = memo || undefined;

        activeSet.log[originalIndex] = updatedEv; 
        
        $('#logEditModal').classList.add('hidden'); 
        currentLogEditIndex = null;
        currentMemoAction = null; 

        setTimeout(() => {
             recomputeFromLog(); 
             save();
             renderAll();
             if (!$('#exportModal').classList.contains('hidden')) showExportScreen();
        }, 0); 
        
    };

    $('#logEditDelete').onclick = () => {
        const originalIndex = Number($('#logEditOriginalIndex').value);
        const activeSet = getActiveSet(); 
        const ev = activeSet.log[originalIndex];

        if (!confirm(`アクション「${ev.action}」のログを削除しますか？`)) return;
        
        activeSet.log.splice(originalIndex, 1);
        
        $('#logEditModal').classList.add('hidden');
        currentLogEditIndex = null;
        currentMemoAction = null; 

        setTimeout(() => {
             recomputeFromLog();
             save();
             renderAll();
             if (!$('#exportModal').classList.contains('hidden')) showExportScreen(); 
        }, 0);
    };
    // ----------------------------------------------------
    }
    
    document.addEventListener('DOMContentLoaded', initUI);


</script>

</body>
</html>
